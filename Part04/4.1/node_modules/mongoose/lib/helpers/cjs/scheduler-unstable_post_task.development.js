uch as `'utf8'` or `'ascii'`.
         */
        unshift(chunk: any, encoding?: BufferEncoding): void;
        /**
         * Prior to Node.js 0.10, streams did not implement the entire `node:stream`module API as it is currently defined. (See `Compatibility` for more
         * information.)
         *
         * When using an older Node.js library that emits `'data'` events and has a {@link pause} method that is advisory only, the`readable.wrap()` method can be used to create a `Readable`
         * stream that uses
         * the old stream as its data source.
         *
         * It will rarely be necessary to use `readable.wrap()` but the method has been
         * provided as a convenience for interacting with older Node.js applications and
         * libraries.
         *
         * ```js
         * const { OldReader } = require('./old-api-module.js');
         * const { Readable } = require('node:stream');
         * const oreader = new OldReader();
         * const myReader = new Readable().wrap(oreader);
         *
         * myReader.on('readable', () => {
         *   myReader.read(); // etc.
         * });
         * ```
         * @since v0.9.4
         * @param stream An "old style" readable stream
         */
        wrap(stream: NodeJS.ReadableStream): this;
        push(chunk: any, encoding?: BufferEncoding): boolean;
        _destroy(error: Error | null, callback: (error?: Error | null) => void): void;
        /**
         * Destroy the stream. Optionally emit an `'error'` event, and emit a `'close'`event (unless `emitClose` is set to `false`). After this call, the readable
         * stream will release any internal resources and subsequent calls to `push()`will be ignored.
         *
         * Once `destroy()` has been called any further calls will be a no-op and no
         * further errors except from `_destroy()` may be emitted as `'error'`.
         *
         * Implementors should not override this method, but instead implement `readable._destroy()`.
         * @since v8.0.0
         * @param error Error which will be passed as payload in `'error'` event
         */
        destroy(error?: Error): this;
        /**
         * Event emitter
         * The defined events on documents including:
         * 1. close
         * 2. data
         * 3. end
         * 4. error
         * 5. pause
         * 6. readable
         * 7. resume
         */
        addListener(event: 'close', listener: () => void): this;
        addListener(event: 'data', listener: (chunk: any) => void): this;
        addListener(event: 'end', listener: () => void): this;
        addListener(event: 'error', listener: (err: Error) => void): this;
        addListener(event: 'pause', listener: () => void): this;
        addListener(event: 'readable', listener: () => void): this;
        addListener(event: 'resume', listener: () => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: 'close'): boolean;
        emit(event: 'data', chunk: any): boolean;
        emit(event: 'end'): boolean;
        emit(event: 'error', err: Error): boolean;
        emit(event: 'pause'): boolean;
        emit(event: 'readable'): boolean;
        emit(event: 'resume'): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: 'close', listener: () => void): this;
        on(event: 'data', listener: (chunk: any) => void): this;
        on(event: 'end', listener: () => void): this;
        on(event: 'error', listener: (err: Error) => void): this;
        on(event: 'pause', listener: () => void): this;
        on(event: 'readable', listener: () => void): this;
        on(event: 'resume', listener: () => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: 'close', listener: () => void): this;
        once(event: 'data', listener: (chunk: any) => void): this;
        once(event: 'end', listener: () => void): this;
        once(event: 'error', listener: (err: Error) => void): this;
        once(event: 'pause', listener: () => void): this;
        once(event: 'readable', listener: () => void): this;
        once(event: 'resume', listener: () => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: 'close', listener: () => void): this;
        prependListener(event: 'data', listener: (chunk: any) => void): this;
        prependListener(event: 'end', listener: () => void): this;
        prependListener(event: 'error', listener: (err: Error) => void): this;
        prependListener(event: 'pause', listener: () => void): this;
        prependListener(event: 'readable', listener: () => void): this;
        prependListener(event: 'resume', listener: () => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: 'close', listener: () => void): this;
        prependOnceListener(event: 'data', listener: (chunk: any) => void): this;
        prependOnceListener(event: 'end', listener: () => void): this;
        prependOnceListener(event: 'error', listener: (err: Error) => void): this;
        prependOnceListener(event: 'pause', listener: () => void): this;
        prependOnceListener(event: 'readable', listener: () => void): this;
        prependOnceListener(event: 'resume', listener: () => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
        removeListener(event: 'close', listener: () => void): this;
        removeListener(event: 'data', listener: (chunk: any) => void): this;
        removeListener(event: 'end', listener: () => void): this;
        removeListener(event: 'error', listener: (err: Error) => void): this;
        removeListener(event: 'pause', listener: () => void): this;
        removeListener(event: 'readable', listener: () => void): this;
        removeListener(event: 'resume', listener: () => void): this;
        removeListener(event: string | symbol, listener: (...args: any[]) => void): this;
        [Symbol.asyncIterator](): AsyncIterableIterator<any>;
    }
    import WritableOptions = internal.WritableOptions;
    class WritableBase extends Stream implements NodeJS.WritableStream {
        /**
         * Is `true` if it is safe to call `writable.write()`, which means
         * the stream has not been destroyed, errored, or ended.
         * @since v11.4.0
         */
        readonly writable: boolean;
        /**
         * Is `true` after `writable.end()` has been called. This property
         * does not indicate whether the data has been flushed, for this use `writable.writableFinished` instead.
         * @since v12.9.0
         */
        readonly writableEnded: boolean;
        /**
         * Is set to `tru